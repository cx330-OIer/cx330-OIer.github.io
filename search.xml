<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Johnson 全源最短路算法复习笔记</title>
    <url>/2022/07/09/Johnson-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p> 对于结点数为 $n$，边数为 $m$ 的有向图 $G$ ，Johnson 全源最短路算法可在 $O(nm + m\log m)$ 时间复杂度内求出有负权边图中任意两点的最短路。</p>
<span id="more"></span>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>Dijkstra 算法可以在 $O(n^2)$ 复杂度（堆优化复杂度为 $O(m\log m)$）内求出无负权边图中任意两点的最短路。而对于有负权边的图，Dijkstra 算法无法处理。</p>
<p>所以，我们可以尝试修改有负权边图中的边权，使有负权边的图变为无负权边的图，再用 Dijkstra 算法处理。</p>
<p>一种容易想到的方法就是给所有边权都加上一个正数 $x$，使所有边权都非负。</p>
<p>但这种方法是错误的。</p>
<p>假设 $u \to v$ 的两条路径（路径 1 是最短路）：</p>
<ol>
<li>$u \to x_1 \to x_2 \to \cdots \to x_a \to v$，路径总长 $dis_1$。</li>
<li>$u \to x_1 \to x_2 \to \cdots \to x_b \to v$，路径总长 $dis_2$。</li>
</ol>
<p>当 $a &gt; b$ 时，由于 $dis_1$ 增加了 $x(a + 1)$，$dis_2$ 增加了 $x(b + 1)$，很可能会使得更新后的 $dis_1’ &gt; dis_2’$ ，改变了最短路径！</p>
<p>Johnson 算法则通过另外一种方法修改边权。</p>
<ol>
<li>建一个超级源点 $0$，从这个点向所有结点连一条边权为 $0$ 的边。</li>
<li>用 SPFA 求出超级源点到每个结点的最短路，记为 $d_0$。</li>
<li>将每条边权 $w_{u \to v}$ 替换为 $w_{u \to v} +d_0(u) - d_0(v)$</li>
<li>对于每个结点跑 Dijkstra 算法。（共 $n$ 轮）</li>
</ol>
<p> 由于最短路的三角不等关系 $d_0(v) \le d_0(u) + w_{u \to v}$，有 $w_{u \to v} + d_0(u) - d_0(v) \ge 0$ 。则修改后没有负权边，满足要求。</p>
<p>那么，为什么 Johnson 算法的修改方式一定不会改变最短路径呢？</p>
<p>我们考虑 $u \to x_1 \to x_2 \to x_3 \to \cdots \to x_n \to v$ 的这样一条路径。</p>
<p>在 $u \to x_1$ 时，增加的边权为 $d_0(u) - d_0(x_1)$；在 $x_1 \to x_2$ 时，增加的边权为 $d_0(x_1) - d_0(x_2)$；在 $x_2 \to x_3$ 时，增加的边权为 $d_0(x_2) - d_0(x_3)$ …… 在 $x_n \to v$ 时，增加的边权为 $d_0(x_n) - d_0(v)$</p>
<p>整条路径上增加的边权之和：<br>$$<br>\begin{aligned}<br>\sum d_0 &amp;&#x3D; d_0(u) - d_0(x_1) + d_0(x_1) - d_0(x_2) + d_0(x_2) + d_0(x_3) + \cdots + d_0(x_n) - d_0(v) \\<br>&amp;&#x3D; d_0(u) - d_0(v)<br>\end{aligned}<br>$$<br>类似地，无论走 $u \to v$ 的哪条路径，整条路径上增加的边权和都是 $d_0(u) - d_0(v)$，这样就保证了 <strong><strong>$u \to v$ 的各个路径相对大小不会发生变化。</strong></strong>原来的最短路径在修改后仍然是最短路径。</p>
<p>这样，Johnson 算法就能正确地求整个图上的最短路了。</p>
<h2 id="代码实现（-Luogu-P5905-Johnson-全源最短路）"><a href="#代码实现（-Luogu-P5905-Johnson-全源最短路）" class="headerlink" title="代码实现（[Luogu] P5905 Johnson 全源最短路）"></a>代码实现（<a href="https://www.luogu.com.cn/problem/P5905">[Luogu] P5905 Johnson 全源最短路</a>）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> nxt;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">int</span> d0[N], upd[N];</span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	e[cnt].w = w;</span><br><span class="line">	e[cnt].to = v;</span><br><span class="line">	e[cnt].nxt = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].to, w = e[i].w;</span><br><span class="line">			<span class="keyword">if</span> (d0[v] &gt; d0[u] + w) &#123;</span><br><span class="line">				d0[v] = d0[u] + w;</span><br><span class="line">				++upd[v];</span><br><span class="line">				<span class="keyword">if</span> (upd[v] == n)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dis[i] = LONG_LONG_MAX;</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = pq.<span class="built_in">top</span>().second, d = pq.<span class="built_in">top</span>().first;</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (d != dis[u])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].to, w = e[i].w;</span><br><span class="line">			<span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(dis[v], v));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>), cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		<span class="built_in">add</span>(u, v, w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = head[i]; j; j = e[j].nxt) &#123;</span><br><span class="line">			e[j].w = e[j].w + d0[i] - d0[e[j].to];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">dij</span>(i);</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dis[j] == LONG_LONG_MAX)</span><br><span class="line">				dis[j] = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dis[j] = dis[j] - d0[i] + d0[j];</span><br><span class="line">			ans += dis[j] * j;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Johnson 全源最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 算法复习笔记</title>
    <url>/2022/07/08/Tarjan-%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>强连通分量：在有向图中，如果一个图的每一个顶点都可从该图其他任意一点到达，则称该图是强连通的。在任意有向图中能够实现强连通的部分我们称其为<strong><strong>强连通分量(strongly connected components, SCC)</strong></strong> 。</p>
<p>换句话说，对于有向图 $G$ 的一个子图 $G’$，若对于 $G’$ 中任意一对顶点 $(u, v)$，都能找到 $u \to v$ 和 $v \to u$ 的通路，那么称子图 $G’$ 是一个强连通分量。</p>
<p>如果把有向图 $G$ 中每个强连通分量都缩成一个顶点，这个有向图将变为 DAG。</p>
<p>使用 Tarjan 算法，可以在 $O(n)$ 时间复杂度内求出强连通分量。</p>
<span id="more"></span>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>显而易见的是，有向图的强连通分量里一定有环。如果我们 dfs 整个有向图并建一棵 dfs 树，强连通分量的部分一定会出现非树边。</p>
<p>我们定义 <code>dfn[x]</code> 表示顶点 $x$ 被 dfs 搜索到的时间戳，<code>low[x]</code> 表示从顶点 $x$ 走若干条树边和<strong>一条非树边</strong>所能到达的顶点中，最早被搜索到的顶点的 <code>dfn</code>（最小的 <code>dfn</code>）。</p>
<p><code>dfn</code> 数组按照 dfs 序直接计算即可， 而<code>low</code> 数组可以用以下方法计算：</p>
<p>对于每个 dfs 访问到的顶点 $x$：</p>
<ol>
<li><p>将 <code>low[x]</code> 初始化为 <code>dfn[x]</code></p>
</li>
<li><p>遍历 $x$ 能到达的所有顶点 $v$</p>
<ul>
<li><p>如果 <code>dfn[v] == 0</code>，则 $v$ 在 dfs 树上是 $u$ 的孩子，$u \to v$ 是一条树边。</p>
<p>先 <code>dfs(v)</code>，再使 <code>low[x] = min(low[x], low[v])</code></p>
</li>
<li><p>如果 <code>dfn[v] != 0</code>，则 $v$ 已经被访问过，$v$ 在 dfs 树上是 $u$ 的祖先，$u \to v$ 是一条非树边。</p>
<p>直接更新 <code>low[x] = min(low[x], dfn[v])</code></p>
</li>
</ul>
</li>
</ol>
<p>那么，如何用 <code>dfn</code> 和 <code>low</code> 数组判断强连通分量呢？</p>
<p>简单模拟一下可以发现，在每个 SCC 中，第一个被访问的顶点 $x_0$，<code>low</code> 值和 <code>dfn</code> 值相等。</p>
<p>其余的顶点，<code>low</code> 值都等于 $x_0$ 的 <code>dfn</code> 值。</p>
<p>所以，当遍历完顶点 $x$ 连接的所有顶点之后，我们判断 <code>low[x]</code> 是否等于 <code>dfn[x]</code>。如果不等则退出，相等则把以 $x$ 为根结点的 dfs 子树计为一个 SCC。</p>
<p>这里我们用一个栈来记录 dfs 序。则 $x$ 和 $x$ 之后进入栈的结点都在一个 SCC 中。</p>
<h2 id="代码实现（-Luogu-P3387-缩点）"><a href="#代码实现（-Luogu-P3387-缩点）" class="headerlink" title="代码实现（[Luogu] P3387 缩点）"></a>代码实现<a href="https://www.luogu.com.cn/problem/P3387">（[Luogu] P3387 缩点）</a></h2><p>这题大概就是先缩点，然后在 DAG 上拓扑排序，跑一个 dp。</p>
<p>代码中，<code>e1</code> 表示原图，<code>e2</code> 表示缩点后的图，<code>sot</code> 数组记录每个顶点所属 SCC 的编号，<code>id</code> 数组记录 SCC 的入度，<code>f</code> 数组是 DAG 的 dp 数组，<code>g</code> 数组记录每个 SCC 中顶点的点权和（SCC 的点权）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> nxt;</span><br><span class="line">&#125; e1[M], e2[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head1[N], head2[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], sot[N];</span><br><span class="line"><span class="type">int</span> a[N], id[N], f[N], g[N];</span><br><span class="line"><span class="type">int</span> edge1_cnt, edge2_cnt;</span><br><span class="line"><span class="type">int</span> dfs_clock, scc_cnt;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	++edge1_cnt;</span><br><span class="line">	e1[edge1_cnt].to = v;</span><br><span class="line">	e1[edge1_cnt].nxt = head1[u];</span><br><span class="line">	head1[u] = edge1_cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	++edge2_cnt;</span><br><span class="line">	e2[edge2_cnt].to = v;</span><br><span class="line">	e2[edge2_cnt].nxt = head2[u];</span><br><span class="line">	head2[u] = edge2_cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	++dfs_clock;</span><br><span class="line">	dfn[x] = low[x] = dfs_clock;</span><br><span class="line">	stk.<span class="built_in">push</span>(x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head1[x]; i; i = e1[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v = e1[i].to;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[v]);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!sot[v])</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">		++scc_cnt;</span><br><span class="line">		<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			sot[stk.<span class="built_in">top</span>()] = scc_cnt;</span><br><span class="line">			<span class="keyword">if</span> (stk.<span class="built_in">top</span>() == x) &#123;</span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				stk.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>), cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="built_in">add1</span>(u, v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!sot[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		g[sot[i]] += a[i];</span><br><span class="line">		f[sot[i]] = g[sot[i]];</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, g[sot[i]]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = head1[i]; j; j = e1[j].nxt) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sot[i] == sot[e1[j].to])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add2</span>(sot[i], sot[e1[j].to]);</span><br><span class="line">			++id[sot[e1[j].to]];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!id[i])</span><br><span class="line">			q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head2[u]; i; i = e2[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e2[i].to;</span><br><span class="line">			f[v] = <span class="built_in">max</span>(f[v], f[u] + g[v]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, f[v]);</span><br><span class="line">			<span class="keyword">if</span> (--id[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束算法复习笔记</title>
    <url>/2022/07/07/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>给出若干变量和约束条件，需要求出一组解，使得所有约束条件均被满足。</p>
<span id="more"></span>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>考虑最简单的约束条件：$x_i - x_j \le y_k$</p>
<p>将其变形：$x_i \le y_k + x_j$</p>
<p>发现它可以转化为单源最短路问题中的三角不等关系，即：$dis_i \le dis_j + w_{i, j}$</p>
<p>所以，我们将每一个变量当作一个点建图：</p>
<ol>
<li>对于 $x_i - x_j \le y_k$ ，我们可以建立一条从 $j$ 到 $i$ 的一条长度为 $y_k$ 的边，跑一遍单源最短路。</li>
<li>对于 $x_i - x_j \ge y_k$ ，我们可以建立一条从 $j$ 到 $i$ 的一条长度为 $y_k$ 的边，跑一遍单源最长路。</li>
</ol>
<p>这里所有的不等号必须是同方向的，如果方向不同就两边同乘 $-1$ 统一不等号的方向。也因此可能有负边权。</p>
<p>不存在解的情况：最短路有负环 或 最长路有正环。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>差分约束算法还可以处理很多种约束条件，比如：</p>
<ol>
<li>$x_i - x_j &lt; y_k$ 可以转化为：<ul>
<li>$x_i - x_j \le y_k - 1 \quad (y_k \in \mathbb{Z})$</li>
</ul>
</li>
<li>$x_i &#x3D; x_j$ 可以转化为：<ul>
<li>$x_i - x_j \le 0$</li>
<li>$x_j - x_i \le 0$</li>
</ul>
</li>
</ol>
<h2 id="代码实现（-SCOI2011-糖果）"><a href="#代码实现（-SCOI2011-糖果）" class="headerlink" title="代码实现（[SCOI2011] 糖果）"></a>代码实现<a href="https://loj.ac/p/2436">（[SCOI2011] 糖果）</a></h2><p>p.s.: 这道题如果跑最短路，而且图不连通的话就假了（）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> nxt;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N], upd[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">int</span> n, k, cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	e[cnt].w = w;</span><br><span class="line">	e[cnt].to = v;</span><br><span class="line">	e[cnt].nxt = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dis[i] = <span class="number">1</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v = e[i].to, w = e[i].w;</span><br><span class="line">			<span class="keyword">if</span> (dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">				<span class="keyword">if</span> (++upd[v] &gt; n)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>), cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, a, b; i &lt;= k; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">switch</span> (x) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="built_in">add</span>(a, b, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				<span class="built_in">add</span>(b, a, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="built_in">add</span>(a, b, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; a == b) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">spfa</span>())</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			ans += dis[i];</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
</search>
